const multiplyVectors=(t,e)=>t.map((s,i)=>e[0].map((r,n)=>s.reduce((s,r,a)=>s+t[i][a]*e[a][n],0))),getBinaryStr=(t,e=0)=>(new Array(e).fill("0").join("")+(t>>>0).toString(2)).slice(-e),insertIntoStr=(t,e,s)=>`${e.slice(0,s)}${t}${e.slice(s)}`,getNList=t=>Object.keys(new Array(t).fill(!0)).map(t=>parseInt(t)),getRotationMatrix=(t,e,s)=>{const i=new Array(t).fill().map((e,s)=>{const i=new Array(t).fill(0);return i[s]=1,i});return s[0]<t&&(i[s[0]][s[0]]=Math.cos(e)),s[1]&&s[1]<t&&(i[s[1]][s[1]]=Math.cos(e)),s[1]&&s[0]<t&&s[1]<t&&(i[s[0]][s[1]]=-Math.sin(e),i[s[1]][s[0]]=Math.sin(e)),i},swapInd=(t,e,s)=>{const i=t[e];return t[e]=t[s],t[s]=i,t},getCombinations=(t,e,s=!1)=>0===t?[[]]:s?e.length===t?[e]:[...getCombinations(t-1,e.slice(1),!0).map(t=>[e[0],...t]),...getCombinations(t,e.slice(1),!0)]:new Array(t).fill(e).reduce((t,e)=>t.reduce((t,s)=>t.concat(e.map(t=>[].concat(s,t))),[])),generateBits=(t,e=["0","1"])=>0===t?[""]:1===t?e:getCombinations(t,e).map(t=>t.join("")).sort(),generateBitmap=(t,e)=>{const s={};return 2===t.length?(s[0]=new Vertex(1),s[0].push(e[0]),s[1]=new Vertex(1),s[1].push(e[1])):t.forEach(t=>s[t]=new Vertex(...t.split("").map(t=>e[parseInt(t)]))),s},generateMFaces=(t,e,s)=>{if(t>e)return[];const i=t,r=e-t,n=getCombinations(r,getNList(e),!0),a=[];for(let o=0;o<n.length;o++)for(let h=0;h<2**(e-t);h++){const e=getBinaryStr(h,r),c=[];for(let a=0;a<2**t;a++){let t=getBinaryStr(a,i);for(let s=0;s<r;s++)t=insertIntoStr(e[s],t,parseInt(n[o][s]));c.push(s[t])}a.push(swapInd(c,2**t-1,2**t-2))}return a};class Vertex extends Array{project(t=2,e){return e?new Vertex(...[...this].slice(0,t).map(t=>t*(1/(e-this[this.length-1])))):new Vertex(...[...this].slice(0,t).map(t=>e?t*(1/(e-d)):t))}toMatrix(){if(1!==this[0].length)return[...this].map(t=>[t])}}class NCube{constructor(t=0,e=[-1,1],s={}){this.dimension=Math.round(t),this.bits=generateBits(this.dimension),this.boundingCoordinates=e,this.bitmap=generateBitmap(this.bits,e),this.backup=generateBitmap(this.bits,e),this.vertices=this.bits.map(t=>this.bitmap[t]),this.edges=generateMFaces(1,this.dimension,this.bitmap),this.faces=generateMFaces(2,this.dimension,this.bitmap),this.facets={1:this.edges,2:this.faces},Object.keys(s).forEach(t=>this[t]=s[t])}getFacets(t=0){return t<0?console.error("IllegalArgumentError: m must be a positive integer"):t%1!=0?console.error("IllegalArgumentError: m must be an integer"):this.facets[t]?this.facets[t]:(this.facets[t]=generateMFaces(t,this.dimension,this.bitmap),this.facets[t])}getFaces(t){return this.getFacets(t)}getMFaces(t){return this.getFacets(t)}reset(){return this.bits.forEach(t=>this.bitmap[t].forEach((e,s)=>this.bitmap[t][s]=this.backup[t][s])),this}scale(t){return this.bits.forEach(e=>this.bitmap[e].forEach((s,i)=>this.bitmap[e][i]*=t)),this}rotate(t=0,e=getCombinations(2,getNList(this.dimension),!0)){return"number"==typeof e[0]&&(e=e.map(t=>[t,t+1])),this.bits.forEach(s=>{const i=e.reduce((e,s)=>new Vertex(...multiplyVectors(getRotationMatrix(this.dimension,t,s),e.toMatrix()).flat()),this.bitmap[s]);this.bitmap[s].forEach((t,e)=>this.bitmap[s][e]=i[e])}),this}}